package main

import (
	"fmt"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

var getExploitationReportsForQueryString = getObjectByQueryFromLedger

/*
* AddExploitationReports function contains business logic to insert new Exploitation Reports to the Ledger
*
* @params   {Array} args
* @property {string} 0       - stringified JSON array of exploitation report.
* @return   {pb.Response}    - peer Response
 */
func addExploitationReports(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var methodName = "addExploitationReports"
	logger.Info("ENTERING >", methodName, args)

	type ExploitationReportResponse struct {
		ExploitationReportUUID string `json:"exploitationReportUUID"`
		Message                string `json:"message"`
		Success                bool   `json:"success"`
	}

	type ExploitationReportOutput struct {
		SuccessCount        int                          `json:"successCount"`
		FailureCount        int                          `json:"failureCount"`
		ExploitationReports []ExploitationReportResponse `json:"exploitationReports"`
	}

	//Check if array length is greater than 0
	if len(args) < 1 {
		return getErrorResponse("Missing arguments: Array of Exploitation Report objects is required")
	}

	exploitationReportOutput := ExploitationReportOutput{}
	exploitationReports := &[]ExploitationReport{}
	exploitationReportResponses := []ExploitationReportResponse{}

	//Unmarshal the args input to an array of exploitation report records
	err := jsonToObject([]byte(args[0]), exploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	// Iterate over Exploitation Reports
	for _, exploitationReport := range *exploitationReports {
		exploitationReport.DocType = EXPLOITATIONREPORT
		exploitationReport.State = INITIAL
		exploitationReportResponse := ExploitationReportResponse{}
		exploitationReportResponse.ExploitationReportUUID = exploitationReport.ExploitationReportUUID
		exploitationReportResponse.Success = true

		//Record Exploitation Report on ledger
		exploitationReportBytes, err := objectToJSON(exploitationReport)
		if err != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = err.Error()
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		exploitationReportExistingBytes, err := stub.GetState(exploitationReport.ExploitationReportUUID)
		if exploitationReportExistingBytes != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = "Exploitation Report already exists!"
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		err = stub.PutState(exploitationReport.ExploitationReportUUID, exploitationReportBytes)
		if err != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = err.Error()
		}

		if exploitationReportResponse.Success {
			exploitationReportOutput.SuccessCount++
		} else {
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
		}
	}

	exploitationReportOutput.ExploitationReports = exploitationReportResponses

	objBytes, _ := objectToJSON(exploitationReportOutput)
	logger.Info("EXITING <", methodName, exploitationReportOutput)
	return shim.Success(objBytes)
}

/*
* UpdateExploitationReports function contains business logic to update Exploitation Reports to the Ledger
*
* @params   {Array} args
* @property {string} 0       - stringified JSON array of exploitation report.
* @return   {pb.Response}    - peer Response
 */
func updateExploitationReports(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var methodName = "updateExploitationReports"
	logger.Info("ENTERING >", methodName, args)

	type ExploitationReportResponse struct {
		ExploitationReportUUID string `json:"exploitationReportUUID"`
		Message                string `json:"message"`
		Success                bool   `json:"success"`
	}

	type ExploitationReportOutput struct {
		SuccessCount        int                          `json:"successCount"`
		FailureCount        int                          `json:"failureCount"`
		ExploitationReports []ExploitationReportResponse `json:"exploitationReports"`
	}

	//Check if array length is greater than 0
	if len(args) < 1 {
		return getErrorResponse("Missing arguments: Array of Exploitation Report objects is required")
	}

	exploitationReportOutput := ExploitationReportOutput{}
	exploitationReports := &[]ExploitationReport{}
	exploitationReportResponses := []ExploitationReportResponse{}

	//Unmarshal the args input to an array of exploitation report records
	err := jsonToObject([]byte(args[0]), exploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	// Iterate over Exploitation Reports
	for _, exploitationReport := range *exploitationReports {
		exploitationReport.DocType = EXPLOITATIONREPORT
		exploitationReportResponse := ExploitationReportResponse{}
		exploitationReportResponse.ExploitationReportUUID = exploitationReport.ExploitationReportUUID
		exploitationReportResponse.Success = true

		//Record Exploitation Report on ledger
		exploitationReportBytes, err := objectToJSON(exploitationReport)
		if err != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = err.Error()
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		exploitationReportExistingBytes, err := stub.GetState(exploitationReport.ExploitationReportUUID)
		if exploitationReportExistingBytes == nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = "Exploitation Report does not exists!"
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		err = stub.PutState(exploitationReport.ExploitationReportUUID, exploitationReportBytes)
		if err != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = err.Error()
		}

		if exploitationReportResponse.Success {
			exploitationReportOutput.SuccessCount++
		} else {
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
		}
	}

	exploitationReportOutput.ExploitationReports = exploitationReportResponses

	objBytes, _ := objectToJSON(exploitationReportOutput)
	logger.Info("EXITING <", methodName, exploitationReportOutput)
	return shim.Success(objBytes)
}

/*
* GetExploitationReports function contains business logic to retrieve Exploitation Reports
*
* @params   {Array} args
* @property {string} 0       - the query string.
* @return   {pb.Response}    - peer Response
 */
func getExploitationReports(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var methodName = "getExploitationReports"
	logger.Info("ENTERING >", methodName, args)

	queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"%s\"}}", EXPLOITATIONREPORT)
	if len(args) == 1 {
		queryString = args[0]
	}

	logger.Info("%s - executing rich query : %s.", methodName, queryString)

	queryResult, err := getExploitationReportsForQueryString(stub, queryString) //getQueryResultInBytes(stub, queryString)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	var resultExploitationReports []ExploitationReport
	err = sliceToStruct(queryResult, &resultExploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	queryResultBytes, err := objectToJSON(resultExploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}
	logger.Info("result(s) received from couch db: %s", string(queryResultBytes))

	//return bytes as result
	return shim.Success(queryResultBytes)
}
