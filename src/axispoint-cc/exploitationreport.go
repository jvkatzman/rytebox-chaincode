package main

import (
	"fmt"
	"reflect"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

var getExploitationReportsForQueryString = getObjectByQueryFromLedger

/*
* generateExploitationReports function contains business logic to insert new Exploitation Reports to the Ledger
*
* @params   {Array} args
* @property {string} 0       - stringified JSON array of exploitation report.
* @return   {pb.Response}    - peer Response
 */
func generateExploitationReports(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var methodName = "addExploitationReports"
	logger.Info("ENTERING >", methodName, args)

	type ExploitationReportResponse struct {
		ExploitationReportUUID string `json:"exploitationReportUUID"`
		Message                string `json:"message"`
		Success                bool   `json:"success"`
	}

	type ExploitationReportOutput struct {
		SuccessCount                int                          `json:"successCount"`
		FailureCount                int                          `json:"failureCount"`
		ExploitationReportResponses []ExploitationReportResponse `json:"exploitationReportResponses"`
		RoyaltyStatements           []RoyaltyStatement           `json:"royaltyStatements"`
		ExploitationReports         []ExploitationReport         `json:"exploitationReports"`
	}

	// check if array length is greater than 0
	if len(args) < 1 {
		return getErrorResponse("Missing arguments: Array of Exploitation Report objects is required")
	}

	exploitationReportOutput := ExploitationReportOutput{}
	exploitationReportOutput.RoyaltyStatements = []RoyaltyStatement{}
	exploitationReports := &[]ExploitationReport{}
	exploitationReportResponses := []ExploitationReportResponse{}

	// unmarshal the args input to an array of exploitation report records
	err := jsonToObject([]byte(args[0]), exploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	// iterate over exploitation reports
	for _, exploitationReport := range *exploitationReports {
		royaltyStatements := []RoyaltyStatement{}
		exploitationReport.DocType = EXPLOITATIONREPORT
		exploitationReport.State = INITIAL
		exploitationReportResponse := ExploitationReportResponse{}
		exploitationReportResponse.ExploitationReportUUID = exploitationReport.ExploitationReportUUID
		exploitationReportResponse.Success = true

		// check if exploitation report with the UUID exists on the ledger.
		exploitationReportExistingBytes, _ := stub.GetState(exploitationReport.ExploitationReportUUID)
		if exploitationReportExistingBytes != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = "Exploitation Report already exists!"
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		// create exploitation report parameters to evaluate the selector expressions
		exploitationReportParameters, _ := getEvaluableParameters(&exploitationReport)

		// query copyright data reports
		queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"%s\",\"isrc\":\"%s\", \"startDate\": { \"$lte\": \"%s\" }, \"endDate\": { \"$gte\": \"%s\" }}}", COPYRIGHTDATAREPORT, exploitationReport.Isrc, exploitationReport.ExploitationDate, exploitationReport.ExploitationDate)
		copyrightDataReports, _ := queryCopyrightDataReports(stub, queryString)

		// set the percentage. used for calculating incomplete royalty statement splits
		totalPercentage := 0.0

		for _, copyrightDataReport := range copyrightDataReports {
			// get all the right holders and evaluate againist right holder selector expression
			for _, rightHolder := range copyrightDataReport.RightHolders {
				isSelectorValid := false
				// generate royalty statements for copy right holders with empty selector
				if rightHolder.Selector == "" {
					isSelectorValid = true
				} else {
					isSelectorValidResult, err := evaluate(rightHolder.Selector, exploitationReportParameters)
					if err != nil {
						logger.Errorf("%s - Failed to get a valid evaluator for right holder ipi %s, selector %s. Error: %s", methodName, rightHolder.IPI, rightHolder.Selector, err.Error())
					}
					//to prevent a crash when test cases are run.
					if reflect.ValueOf(isSelectorValidResult).IsValid() {
						isSelectorValid = isSelectorValidResult.(bool)
					}
				}
				if isSelectorValid {
					// generate royalty statment
					royaltyStatement := RoyaltyStatement{}
					// set the royalty statment right holder
					royaltyStatement.RightHolder = rightHolder.IPI
					// set the right type to OWNERSHIP as the royalty statement is between DSP and owner adminsitrator
					royaltyStatement.RightType = OWNERSHIP
					royaltyStatement.Amount = toFixed(exploitationReport.Amount*rightHolder.Percent*0.01, 2)
					royaltyStatements = append(royaltyStatements, royaltyStatement)

					totalPercentage += rightHolder.Percent
				}
			}
		}

		// check the total percentage
		if totalPercentage > 100 {
			// if totalPercentage > 100, do not generate royalty reports
			exploitationReport.State = INCONSISTENT_COPYRIGHT_SPLIT
		} else {
			// if totalPercentage < 100, set the exploitation report state as incomplete
			if len(royaltyStatements) == 0 {
				exploitationReport.State = UNKOWN_ISRC
			} else if totalPercentage == 0 { // if royal statements exisys and the total percentage is 0
				exploitationReport.State = INCOMPLETE_COPYRIGHT_SPLIT
			} else if totalPercentage < 100 { // totalPercentage < 100 if there are missing copyright holders
				exploitationReport.State = MISSING_COPYRIGHT_HOLDER
			}

			// for all the royalty statments, find the owner administrator and affiliation
			for _, royaltyStatement := range royaltyStatements {
				royaltyStatement.DocType = ROYALTYSTATEMENT
				royaltyStatement.Source = exploitationReport.Source
				royaltyStatement.SongTitle = exploitationReport.SongTitle
				royaltyStatement.Isrc = exploitationReport.Isrc
				royaltyStatement.ExploitationReportUUID = exploitationReport.ExploitationReportUUID
				royaltyStatement.ExploitationDate = exploitationReport.ExploitationDate
				royaltyStatement.WriterName = exploitationReport.WriterName
				royaltyStatement.Units = exploitationReport.Units
				royaltyStatement.Territory = exploitationReport.Territory
				royaltyStatement.UsageType = exploitationReport.UsageType
				royaltyStatement.Administrator = ""
				royaltyStatement.Collector = ""

				//removing the following since owner administrations and affiliations are deprecated.
				// query owner administrations
				/*queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"%s\",\"owner\":\"%s\", \"startDate\": { \"$lte\": \"%s\" }, \"endDate\": { \"$gte\": \"%s\" }}}", OWNERADMINISTRATION, royaltyStatement.RightHolder, exploitationReport.ExploitationDate, exploitationReport.ExploitationDate)
				ownerAdministrations, _ := queryOwnerAdministrations(stub, queryString)
				royaltyStatement.State = MISSING_REPRESENTATIVE

				for _, ownerAdministration := range ownerAdministrations {
					for _, representation := range ownerAdministration.Representations {
						isSelectorValid := false
						// set owner representation for a royalty statement with empty selector
						if representation.Selector == "" {
							isSelectorValid = true
						} else {
							isSelectorValidResult, _ := evaluate(representation.Selector, exploitationReportParameters)
							isSelectorValid = isSelectorValidResult.(bool)
						}
						if isSelectorValid {
							royaltyStatement.State = MISSING_AFFILIATE
							// set the royalty statement administrator
							royaltyStatement.Administrator = representation.Representative

							// query owner administrations
							queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"%s\",\"administrator\":\"%s\", \"startDate\": { \"$lte\": \"%s\" }, \"endDate\": { \"$gte\": \"%s\" }}}", ADMINISTRATORAFFILIATION, representation.Representative, exploitationReport.ExploitationDate, exploitationReport.ExploitationDate)
							administratorAffiliations, _ := queryAdministratorAffiliations(stub, queryString)

							for _, administratorAffiliation := range administratorAffiliations {
								for _, affiliation := range administratorAffiliation.Affiliations {
									isSelectorValid = false
									// set administrator affiliation for a royalty statement with empty selector
									if affiliation.Selector == "" {
										isSelectorValid = true
									} else {
										isSelectorValidResult, _ := evaluate(affiliation.Selector, exploitationReportParameters)
										isSelectorValid = isSelectorValidResult.(bool)
									}
									if isSelectorValid {
										royaltyStatement.State = INITIAL
										// set the royalty statement afflliation
										royaltyStatement.Collector = affiliation.Affiliate
										break
									}
								}
							}
							break
						}
					}
				}*/
				// add the royalty statement to output
				exploitationReportOutput.RoyaltyStatements = append(exploitationReportOutput.RoyaltyStatements, royaltyStatement)
			}
		}

		// record exploitation report on ledger
		// exploitationReportBytes, err := objectToJSON(exploitationReport)
		// if err != nil {
		// 	exploitationReportResponse.Success = false
		// 	exploitationReportResponse.Message = err.Error()
		// 	exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
		// 	exploitationReportOutput.FailureCount++
		// 	continue
		// }

		exploitationReportOutput.ExploitationReports = append(exploitationReportOutput.ExploitationReports, exploitationReport)
		// err = stub.PutState(exploitationReport.ExploitationReportUUID, exploitationReportBytes)
		// if err != nil {
		// 	exploitationReportResponse.Success = false
		// 	exploitationReportResponse.Message = err.Error()
		// }

		if exploitationReportResponse.Success {
			exploitationReportOutput.SuccessCount++
		} else {
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
		}
	}

	exploitationReportOutput.ExploitationReportResponses = exploitationReportResponses

	objBytes, _ := objectToJSON(exploitationReportOutput)
	logger.Info("EXITING <", methodName, exploitationReportOutput)
	return shim.Success(objBytes)
}

/*
* updateExploitationReports function contains business logic to update Exploitation Reports to the Ledger
*
* @params   {Array} args
* @property {string} 0       - stringified JSON array of exploitation report.
* @return   {pb.Response}    - peer Response
 */
func updateExploitationReports(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var methodName = "updateExploitationReports"
	logger.Info("ENTERING >", methodName, args)

	type ExploitationReportResponse struct {
		ExploitationReportUUID string `json:"exploitationReportUUID"`
		Message                string `json:"message"`
		Success                bool   `json:"success"`
	}

	type ExploitationReportOutput struct {
		SuccessCount        int                          `json:"successCount"`
		FailureCount        int                          `json:"failureCount"`
		ExploitationReports []ExploitationReportResponse `json:"exploitationReports"`
	}

	//Check if array length is greater than 0
	if len(args) < 1 {
		return getErrorResponse("Missing arguments: Array of Exploitation Report objects is required")
	}

	exploitationReportOutput := ExploitationReportOutput{}
	exploitationReports := &[]ExploitationReport{}
	exploitationReportResponses := []ExploitationReportResponse{}

	//Unmarshal the args input to an array of exploitation report records
	err := jsonToObject([]byte(args[0]), exploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	// iterate over Exploitation Reports
	for _, exploitationReport := range *exploitationReports {
		exploitationReport.DocType = EXPLOITATIONREPORT
		exploitationReportResponse := ExploitationReportResponse{}
		exploitationReportResponse.ExploitationReportUUID = exploitationReport.ExploitationReportUUID
		exploitationReportResponse.Success = true

		// convert exploitation report to bytes
		exploitationReportBytes, err := objectToJSON(exploitationReport)
		if err != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = err.Error()
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		// check if exploitation report with the UUID exists on the ledger.
		exploitationReportExistingBytes, err := stub.GetState(exploitationReport.ExploitationReportUUID)
		if exploitationReportExistingBytes == nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = "Exploitation Report does not exist!"
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		// update exploitation report on ledger
		err = stub.PutState(exploitationReport.ExploitationReportUUID, exploitationReportBytes)
		if err != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = err.Error()
		}

		if exploitationReportResponse.Success {
			exploitationReportOutput.SuccessCount++
		} else {
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
		}
	}

	exploitationReportOutput.ExploitationReports = exploitationReportResponses

	objBytes, _ := objectToJSON(exploitationReportOutput)
	logger.Info("EXITING <", methodName, exploitationReportOutput)
	return shim.Success(objBytes)
}

/*
* insertExploitationReports function contains business logic to insert Exploitation Reports to the Ledger
*
* @params   {Array} args
* @property {string} 0       - stringified JSON array of exploitation report.
* @return   {pb.Response}    - peer Response
 */
func insertExploitationReports(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var methodName = "insertExploitationReports"
	logger.Info("ENTERING >", methodName, args)

	type ExploitationReportResponse struct {
		ExploitationReportUUID string `json:"exploitationReportUUID"`
		Message                string `json:"message"`
		Success                bool   `json:"success"`
	}

	type ExploitationReportOutput struct {
		SuccessCount        int                          `json:"successCount"`
		FailureCount        int                          `json:"failureCount"`
		ExploitationReports []ExploitationReportResponse `json:"exploitationReports"`
	}

	//Check if array length is greater than 0
	if len(args) < 1 {
		return getErrorResponse("Missing arguments: Array of Exploitation Report objects is required")
	}

	exploitationReportOutput := ExploitationReportOutput{}
	exploitationReports := &[]ExploitationReport{}
	exploitationReportResponses := []ExploitationReportResponse{}

	//Unmarshal the args input to an array of exploitation report records
	err := jsonToObject([]byte(args[0]), exploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	// iterate over Exploitation Reports
	for _, exploitationReport := range *exploitationReports {
		exploitationReport.DocType = EXPLOITATIONREPORT
		exploitationReportResponse := ExploitationReportResponse{}
		exploitationReportResponse.ExploitationReportUUID = exploitationReport.ExploitationReportUUID
		exploitationReportResponse.Success = true

		// check if exploitation report with the UUID exists on the ledger.
		exploitationReportExistingBytes, _ := stub.GetState(exploitationReport.ExploitationReportUUID)
		if exploitationReportExistingBytes != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = "Exploitation Report already exists!"
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		// convert exploitation report to bytes
		exploitationReportBytes, err := objectToJSON(exploitationReport)
		if err != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = err.Error()
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
			continue
		}

		// update exploitation report on ledger
		err = stub.PutState(exploitationReport.ExploitationReportUUID, exploitationReportBytes)
		if err != nil {
			exploitationReportResponse.Success = false
			exploitationReportResponse.Message = err.Error()
		}

		if exploitationReportResponse.Success {
			exploitationReportOutput.SuccessCount++
		} else {
			exploitationReportResponses = append(exploitationReportResponses, exploitationReportResponse)
			exploitationReportOutput.FailureCount++
		}
	}

	exploitationReportOutput.ExploitationReports = exploitationReportResponses

	objBytes, _ := objectToJSON(exploitationReportOutput)
	logger.Info("EXITING <", methodName, exploitationReportOutput)
	return shim.Success(objBytes)
}

/*
* getExploitationReports function contains business logic to retrieve Exploitation Reports
*
* @params   {Array} args
* @property {string} 0       - the query string.
* @return   {pb.Response}    - peer Response
 */

func getExploitationReports(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var methodName = "getExploitationReports"
	logger.Info("ENTERING >", methodName, args)

	queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"%s\"}}", EXPLOITATIONREPORT)
	if len(args) == 1 {
		queryString = args[0]
	}

	logger.Info("%s - executing rich query : %s.", methodName, queryString)

	// get exploitation reports based on the rich query selector
	queryResult, err := getExploitationReportsForQueryString(stub, queryString) //getQueryResultInBytes(stub, queryString)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	var resultExploitationReports []ExploitationReport
	err = sliceToStruct(queryResult, &resultExploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}

	queryResultBytes, err := objectToJSON(resultExploitationReports)
	if err != nil {
		return getErrorResponse(err.Error())
	}
	logger.Info("result(s) received from couch db: %s", string(queryResultBytes))

	//return bytes as result
	return shim.Success(queryResultBytes)
}
